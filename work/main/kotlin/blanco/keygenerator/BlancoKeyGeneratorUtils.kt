/*
 * This source code is auto-generated by blanco Framework.
 */
package blanco.keygenerator

import blanco.keygenerator.enums.BlancoKeyGeneratorKeyTypes
import blanco.keygenerator.exceptions.BlancoKeyGeneratorException
import blanco.keygenerator.valueobjects.BlancoKeyGeneratorKeyPhrase
import java.nio.ByteBuffer
import java.nio.CharBuffer
import java.nio.charset.Charset
import java.nio.charset.CharsetEncoder
import java.nio.charset.CoderResult
import java.nio.charset.CodingErrorAction
import java.security.MessageDigest
import java.util.Base64
import kotlin.math.pow
import kotlin.math.sign
import kotlin.text.Charsets.UTF_8

/**
 * Utilities for blancoKeyGenerator
 */
class BlancoKeyGeneratorUtils {
    companion object {
        /**
         * Convert string item into key string
         */
        @JvmStatic
        fun string2key(item: String, keyPhrase: BlancoKeyGeneratorKeyPhrase): String {
            var result = ""
            if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.RAW.type) {
                result = item;
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.B64.type) {
                result = Base64.getUrlEncoder().withoutPadding().encodeToString(item.toByteArray(UTF_8))
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.HEX.type) {
                result = printHexBinary(item.toByteArray(UTF_8))
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA1.type || keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA256.type) {
                result = hashString(item, keyPhrase.type, UTF_8)
            } else {
                throw BlancoKeyGeneratorException(keyPhrase.type + " is not valid for string type key.")
            }
            return truncateStringByBytes(result, UTF_8, keyPhrase.length, false)
        }

        /**
         * Convert key into string.
         */
        @JvmStatic
        fun key2string(encoded: String, keyPhrase: BlancoKeyGeneratorKeyPhrase): String {
            var decoded: String = ""
            if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.RAW.type) {
                decoded = encoded;
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.B64.type) {
                println(" hoge " + Base64.getUrlDecoder().decode(encoded))
                decoded = String(Base64.getUrlDecoder().decode(encoded), UTF_8)
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.HEX.type) {
                decoded = String(parseHexBinary(encoded), UTF_8)
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA1.type || keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA256.type) {
                decoded = hashString(encoded, keyPhrase.type, UTF_8)
            } else {
                throw BlancoKeyGeneratorException(keyPhrase.type + " is not valid for string type key.")
            }
            return decoded
        }

        /**
         * Convert integer item into key string.
         */
        @JvmStatic
        fun long2key(item: Long, keyPhrase: BlancoKeyGeneratorKeyPhrase): String {
            var result = ""
            var paddingLeft = false
            if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.RAW.type) {
                result = item.toString()
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.B64.type) {
                result = Base64.getUrlEncoder().withoutPadding().encodeToString(Long.toString().toByteArray(UTF_8))
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.HEX.type) {
                result = item.toString(16)
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.BIN.type) {
                result = item.toString(2)
                paddingLeft = true
            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA1.type || keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA256.type) {
                result = hashString(item.toString(), keyPhrase.type, UTF_8)
            } else {
                throw BlancoKeyGeneratorException(keyPhrase.type + " is not valid for integer type key.")
            }
            return truncateStringByBytes(result, UTF_8, keyPhrase.length, paddingLeft)
        }

//        @JvmStatic
//        fun key2long(encoded: String, keyPhrase: BlancoKeyGeneratorKeyPhrase): Long {
//            var result: Long = 0L
//            if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.RAW.type) {
//                result = encoded.toLong()
//            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.B64.type) {
//                result = Base64.getUrlDecoder().decode(encoded)
//            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.HEX.type) {
//                result = item.toString(16)
//            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.BIN.type) {
//                result = item.toString(2)
//                paddingLeft = true
//            } else if (keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA1.type || keyPhrase.type == BlancoKeyGeneratorKeyTypes.SHA256.type) {
//                result = hashString(item.toString(), keyPhrase.type, UTF_8)
//            } else {
//                throw BlancoKeyGeneratorException(keyPhrase.type + " is not valid for integer type key.")
//            }
//
//        }

        /**
         * Hash a string.
         */
        @JvmStatic
        fun hashString(target: String, hashType:String, charset: Charset): String {
            val hashByte = MessageDigest.getInstance(hashType).digest(target.toByteArray(charset))
            return printHexBinary(hashByte)
        }

        /**
         * truncate a string to specified length.
         */
        @JvmStatic
        fun truncateStringByBytes(original: String, charset:Charset, limit: Int, leftPaddingZero: Boolean): String {
            val byteBuffer: ByteBuffer = ByteBuffer.allocate(limit)
            val charBuffer: CharBuffer = CharBuffer.wrap(original)
            val encoder: CharsetEncoder = charset.newEncoder()
                .onMalformedInput(CodingErrorAction.REPLACE)
                .onUnmappableCharacter(CodingErrorAction.REPLACE)
                .reset()
            val coderResult: CoderResult = encoder.encode(charBuffer, byteBuffer, true)
            if (!coderResult.isOverflow) {
                var result = original
                if (leftPaddingZero) {
                    val padlen = limit - original.length
                    if (padlen > 0) {
                        result = getStringsLoop("0", padlen) + result
                    }
                }
                return result
            }
            encoder.flush(byteBuffer)
            return charBuffer.flip().toString()
        }

        /**
         * encode long as big endian expression of base64
         */
        @JvmStatic
        fun long2b64(value: Long, length: Int): String {
            if (length < 1 || length > 11) {
                // out of the range of long.
                throw BlancoKeyGeneratorException("Length should be between 1 and 11, because of integer is 64 bit digit.")
            }
            var expectedBits = 6 * length
            if (expectedBits > 64) {
                expectedBits = 64
            }
            val maxValue = 2.toDouble().pow((expectedBits - 1).toDouble()).toLong() - 1
            val minValue = (maxValue * -1) - 1
//            println("" + maxValue + ", " + minValue)
            if (value < minValue || value > maxValue) {
                throw BlancoKeyGeneratorException("%d is exceed the limit of %d length of base64 encoding.".format(value, length))
            }

            val byteSize = (Math.ceil((expectedBits.toDouble() / 8))).toInt()
            val arraySize = (Math.ceil(byteSize.toDouble() / 6) * 6).toInt()

            val encoded = Base64
                .getUrlEncoder()
                .withoutPadding()
                .encodeToString(ByteArray(arraySize) {
                        i -> (value ushr ((arraySize - 1 - i) * 8)).toByte()
                })
            /*
             * to align bit order to right side, byte array needs
             * some multiples of 24 (lowest common multiple 6 and 8) bits
             * then 72 bits is 9 bytes for long int,
             * and 9 byte array produce 12 length base64 string.
             */
            val b64Len = arraySize * 8 / 6
            return encoded.substring(b64Len - length)
        }

        /**
         * Decode base64 encoded long.
         */
        @JvmStatic
        fun b642long(base64: String): Long {
            val length = base64.length
            if (length < 1 || length > 11) {
                throw BlancoKeyGeneratorException("Length should be between 1 and 11, because of long is shown under 11 characters.")
            }
            var expectedBits = 6 * length
            if (expectedBits > 64) {
                expectedBits = 64
            }
            val leftChar = base64.get(0)
            var leftPadding = "A"
            if ((leftChar >= 'g' && leftChar <= 'z') ||
                (leftChar >= '0' && leftChar <= '9') ||
                (leftChar == '-') || (leftChar == '_')) {
                leftPadding = "_"
            }

            var encoded = base64
            for (i in 0..11 - length) { /* long maximum length is 12 */
                encoded = leftPadding + encoded
            }
            val bytes = Base64.getUrlDecoder().decode(encoded)
            /* Big Endian */
            var result: Long = 0
            for (i in 0..8) { /* it should be 9 bytes array. */
                val value = bytes.getOrNull(i) ?: 0
                result = result shl 8
                result = result or value.toUByte().toLong()
            }
            return result
        }

        @JvmField
        val hexCode: CharArray = "0123456789ABCDEFGHIJKLMNOPQRSTUV".toCharArray()

        /**
         * Encode long to baseN expression.
         */
        @JvmStatic
        fun long2baseN(value: Long, base: Int, length: Int): String {
            var bitSize = 1
            var mask: Long = -1
            if (base == 2) {
                bitSize = 1
                mask = 1
            } else if (base == 4) {
                bitSize = 2
                mask = 3
            } else if (base == 8) {
                bitSize = 3
                mask = 7
            } else if (base == 16) {
                bitSize = 4
                mask = 15
            } else if (base == 32) {
                bitSize = 5
                mask = 31
            } else if (base == 64) {
                return long2b64(value, length)
            } else {
                throw BlancoKeyGeneratorException("Base should be power of 2.")
            }
            val maxLength = Math.ceil(64.toDouble() / bitSize)
            var expectedBits = bitSize * length
            if (expectedBits > 64) {
                expectedBits = 64
            }
            if (expectedBits < 2 || length > maxLength) {
                throw BlancoKeyGeneratorException("Length should be between 1 and " + maxLength + " because of long is shown under " + maxLength + " characters in base " + base + " .")
            }
            val maxValue = 2.toDouble().pow((expectedBits - 1).toDouble()).toLong() - 1
            val minValue = (maxValue * -1) - 1
            if (value < minValue || value > maxValue) {
                throw BlancoKeyGeneratorException("%d is exceed the limit of %d length of base %d encoding.".format(value, length, base))
            }

            var strN = ""
            var tmpLong = value
            for (i in 0 until length) {
                val cvalue = tmpLong and mask
                val char = hexCode[cvalue.toInt()]
                strN = char + strN
                tmpLong = tmpLong shr bitSize
            }
            return strN
        }

        @JvmStatic
        fun baseN2long(encoded: String, base: Int): Long {
            val length = encoded.length

            var bitSize = 0
            var signPadding = '1'
            var signMask = 1
            if (base == 2) {
                bitSize = 1
            } else if (base == 4) {
                bitSize = 2
                signPadding = '3'
                signMask = 2
            } else if (base == 8) {
                bitSize = 3
                signPadding = '7'
                signMask = 4
            } else if (base == 16) {
                bitSize = 4
                signPadding = 'F'
                signMask = 8
            } else if (base == 32) {
                bitSize = 5
                signPadding = 'V'
                signMask = 16
            } else if (base == 64) {
                return b642long(encoded)
            } else {
                throw BlancoKeyGeneratorException("Base should be power of 2.")
            }

            val maxLength: Int = Math.ceil(64.toDouble() / bitSize).toInt()
            var expectedBits = bitSize * length
            if (expectedBits > 64) {
                expectedBits = 64
            }
            if (expectedBits < 2 || length > maxLength) {
                throw BlancoKeyGeneratorException("Length should be between 1 and " + maxLength + " because of long is shown under " + maxLength + " characters in base " + base + " .")
            }

            var tmpEncoded = encoded.toUpperCase()
            if ((hexCode.binarySearch(tmpEncoded[0]) and signMask) == 0) {
                signPadding = '0'
            }

            var tmpLength = maxLength - length
            for (i in 0 until tmpLength) {
                tmpEncoded = signPadding + tmpEncoded
            }
            println(tmpEncoded)
            tmpLength = tmpEncoded.length

            var value: Long = 0
            tmpEncoded.forEach {
                val shiftBit = bitSize * --tmpLength
                value += hexCode.binarySearch(it).toLong() shl shiftBit
            }
            return value
        }


        /**
         * Print byte array data into hex string.
         */
        @JvmStatic
        fun printHexBinary(data: ByteArray): String {
            val r: StringBuffer = StringBuffer()
            for (b in data) {
                r.append(hexCode[(b.toInt() ushr 4) and  0xf])
                r.append(hexCode[(b.toInt() and 0x0f)])
            }
            return r.toString()
        }

        /**
         * Parse hex string as byte array.
         */
        @JvmStatic
        fun parseHexBinary(hexString: String): ByteArray {
            val len = hexString.length
            if ((len % 2) != 0 ) {
                throw BlancoKeyGeneratorException("hexBinary needs to be even-length: " + hexString)
            }

            val out: ByteArray = ByteArray(len / 2)
            var isHigh = true;
            var buf: Int = 0
            var counter = 0
            hexString.forEach {
                val v = hexToBin(it)
                if (isHigh) {
                    buf = v shl 4
                    isHigh = false
                } else {
                    buf += v
                    out[counter / 2] = buf.toByte()
                    buf = 0
                    counter += 2
                    isHigh = true
                }
            }

            return out
        }

        /**
         * Convert
         */
        @JvmStatic
        fun hexToBin(ch: Char): Int {
            if ('0' <= ch && ch <= '9') {
                return ch - '0';
            }
            if ('A' <= ch && ch <= 'F') {
                return ch - 'A' + 10;
            }
            if ('a' <= ch && ch <= 'f') {
                return ch - 'a' + 10;
            }
            return -1;
        }

        /**
         * Create looped string from string.
         */
        @JvmStatic
        fun getStringsLoop(base: String, count: Int): String {
            var result = ""
            for (i in 0 until  count) {
                result += base
            }
            return result
        }
    }
}
